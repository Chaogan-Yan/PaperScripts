% To Calculate the FC Maps of sgACC and DLPFC masks using REST-meta-MDD subjects
% Xiao Chen 220808
% chenxiaophd@gmail.com

%% initilization
clear;clc;

WorkDir = '/mnt/Data5/RfMRILab/Chenxiao/sgACC_Project';
DataDir = [WorkDir, '/Data'];
OutputDir = [WorkDir, '/Analyses_V2/group_diff_target/FC_maps'];
if ~exist(OutputDir, "dir"); mkdir(OutputDir); end
% where ROI masks were stored
MaskDir = [WorkDir, '/Analyses_V2/group_diff_target'];
SubjectListFile = [DataDir,'/sub_list220916.txt'];

load(['/mnt/Data7/RfMRILab/Yan/YAN_Work/REST_meta-MDD_Surf/Organized/', ...
    'Processing_CorrectedFun/Cfg_3_Processing.mat']);
Cfg.WorkingDir = '/mnt/Data5/RfMRILab/Chenxiao/sgACC_Project/Data';
Cfg.MaskFileVolu = [Cfg.WorkingDir,'/Masks/AllResampled_BrainMask_05_91x109x91.nii'];
Cfg.SubjectID = importdata(SubjectListFile);

GSRSet = {'FunSurfWCF','FunSurfWglobalCF'};
GSRVoluSet = {'FunVoluWCF','FunVoluWglobalCF'};

[DPABIPath, fileN, extn] = fileparts(which('DPABI.m'));
ProgramPath=fullfile(DPABIPath, 'DPARSF');


% % All sgACC and DLPFC masks
% MaskSurfaceLeftSet = {'Brodmann_Mai_Matajnik_BA25_fsaverage5_lh',  ...
%                       'glasser_BA25_lh', 'Schaefer_sgACC_lh',...
%                       '5cmMethod_20mm_Grey_Matter_fsaverage5_masked_lh',  ...
%                       'BA_9_15mm_Grey_Matter_fsaverage5_masked_lh', ...
%                       'BA_9_20mm_Grey_Matter_fsaverage5_masked_lh', ...
%                       'BA_46_20mm_Grey_Matter_fsaverage5_masked_lh', ...
%                       'F3Beam_20mm_Grey_Matter_fsaverage5_masked_lh', ...
%                       'SGC_group_target_Grey_Matter_fsaverage5_masked_lh'
%                       };
% MaskSurfaceRightSet = {'Brodmann_Mai_Matajnik_BA25_fsaverage5_rh', ...
%                             'glasser_BA25_rh', 'Schaefer_sgACC_rh', ...
%                             'Fox_2012_Grey_Matter_fsaverage5_masked_rh', ...
%                             'Liston_2014_Grey_Matter_fsaverage5_masked_rh'
%                             };
%                   
% MaskVolumeSet = {'Brodmann_Mai_Matajnik_BA25_lh', 'Brodmann_Mai_Matajnik_BA25_rh',...
%                  'Fox_2012_Grey_Matter', 'glasser_BA25_MNI_lh', ...
%                  'glasser_BA25_MNI_rh', ...
%                  'Liston_2014_Grey_Matter', 'Schaefer_sgACC_lh', ...
%                  'Schaefer_sgACC_rh',...
%                  '5cmMethod_20mm_Grey_Matter', 'BA_9_9mm_Grey_Matter', ...
%                  'BA_9_15mm_Grey_Matter', 'BA_9_20mm_Grey_Matter', ...
%                  'BA_46_20mm_Grey_Matter', 'F3Beam_20mm_Grey_Matter', ...
%                  'SGC_group_target_Grey_Matter'
%                  };
             
% sgACC group difference target
MaskSurfaceLeftSet = {'group_diff_target_V2_C1_Grey_Matter_fsaverage5_masked_lh', ...
                      'group_diff_target_V2_C2_Grey_Matter_fsaverage5_masked_lh'
                      };
MaskSurfaceRightSet = {};
                  
MaskVolumeSet = {'group_diff_target_V2_C1_Grey_Matter', 'group_diff_target_V2_C2_Grey_Matter'
                 };

             
%% reslice the volume masks
for iMask = 1:length(MaskVolumeSet)
    InputFile = [MaskDir,filesep,MaskVolumeSet{iMask},'.nii'];
    OutputFile = [MaskDir,filesep,MaskVolumeSet{iMask},'_Reslice.nii'];
    NewVoxSize = [];
    hld = 0;
    TargetSpace = [DataDir, '/Masks/AllResampled_BrainMask_05_91x109x91.nii'];
    y_Reslice(InputFile,OutputFile,NewVoxSize,hld, TargetSpace);
end

%% open par pool
poolobj = gcp('nocreate');
delete(poolobj);
parpool(30);

%% do calculation
for iGSR = 1:2
    Cfg.StartingDirName = GSRSet{iGSR};
    Cfg.StartingDirName_Volume = GSRVoluSet{iGSR};
    %Calculate Seed Based Functional Connectivity
    parfor i=1:length(Cfg.SubjectID)
        % roi on the left hemisphere
        for iMask = 1:length(MaskSurfaceLeftSet)
            %%
            if ~exist([OutputDir,filesep,'Results',filesep,'FunSurfLH',filesep, ...
                    'ROISignals_',Cfg.StartingDirName,'_',MaskSurfaceLeftSet{iMask}], 'dir')
                
                mkdir([OutputDir,filesep,'Results',filesep,'FunSurfLH',filesep, ...
                    'ROISignals_',Cfg.StartingDirName,'_',MaskSurfaceLeftSet{iMask}]);
            end
            DirName=dir(fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i}, ...
                '*fsaverage5_hemi-L*.func.gii'));
            
            % extract time series
            for iFile=1:length(DirName)
                FileName=DirName(iFile).name;
                [ROISignalsSurfLH] = y_ExtractROISignal_Surf( ...
                    fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i},FileName), ...
                            {[MaskDir,filesep,MaskSurfaceLeftSet{iMask},'.gii']}, ...
                            [OutputDir,filesep,'Results',filesep,'FunSurfLH',filesep, ...
                            'ROISignals_',Cfg.StartingDirName,'_',MaskSurfaceLeftSet{iMask}, ...
                            filesep,Cfg.SubjectID{i}], ...
                            '', ...  % no brain mask
                            0);
            end

            % Calculate Functional Connectivity by Seed based Correlation Anlyasis
            % Left Hemi
            if ~exist([OutputDir,filesep,'Results',filesep,'FunSurfLH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_',MaskSurfaceLeftSet{iMask}], 'dir')
                
                mkdir([OutputDir,filesep,'Results',filesep,'FunSurfLH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_',MaskSurfaceLeftSet{iMask}]);
            end
            DirName=dir(fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i}, ...
                                '*fsaverage5_hemi-L*.func.gii'));
            
            for iFile=1:length(DirName)
                FileName=DirName(iFile).name;
                y_SCA_Surf(fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i},FileName), ...
                    {ROISignalsSurfLH}, ... 
                    [OutputDir,filesep,'Results',filesep,'FunSurfLH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_', ...
                    MaskSurfaceLeftSet{iMask},filesep,'FC_',Cfg.SubjectID{i},'.func.gii'], ...
                    Cfg.MaskFileSurfLH, ...
                    0);
            end

            % Right Hemi
            if ~exist([OutputDir,filesep,'Results',filesep,'FunSurfRH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_',MaskSurfaceLeftSet{iMask}], 'dir')
                
                mkdir([OutputDir,filesep,'Results',filesep,'FunSurfRH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_',MaskSurfaceLeftSet{iMask}]);
            end
            
            DirName=dir(fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i}, ...
                '*fsaverage5_hemi-R*.func.gii'));
            for iFile=1:length(DirName)
                FileName=DirName(iFile).name;
                y_SCA_Surf(fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i},FileName), ...
                    {ROISignalsSurfLH}, ... 
                    [OutputDir,filesep,'Results',filesep,'FunSurfRH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_',MaskSurfaceLeftSet{iMask}, ...
                    filesep,'FC_',Cfg.SubjectID{i},'.func.gii'], ...
                    Cfg.MaskFileSurfRH, ...
                    0);
            end

            if (Cfg.IsProcessVolumeSpace==1) &&  ...
               (~exist([OutputDir,filesep,'Results',filesep,'FunVolu',filesep, ...
               'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName_Volume,'_', ...
               MaskSurfaceLeftSet{iMask}], 'dir'))
           
               mkdir([OutputDir,filesep,'Results',filesep,'FunVolu',filesep, ...
                   'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName_Volume,'_', ...
                   MaskSurfaceLeftSet{iMask}]);
            end
            % Volume
            if (Cfg.IsProcessVolumeSpace==1)
                % Calculate Functional Connectivity by Seed based Correlation Anlyasis
                y_SCA([Cfg.WorkingDir,filesep,Cfg.StartingDirName_Volume,filesep, ...
                    Cfg.SubjectID{i}], ...% use extracted time series as roi
                    {ROISignalsSurfLH}, ...
                    [OutputDir,filesep,'Results',filesep,'FunVolu',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName_Volume,'_', ...
                    MaskSurfaceLeftSet{iMask},filesep,'FC_',Cfg.SubjectID{i},'.nii'], ...
                    Cfg.MaskFileVolu, ...
                    0);
            end
        end

        % roi on the righ hemisphere
        for iMask = 1:length(MaskSurfaceRightSet)
            if ~exist([OutputDir,filesep,'Results',filesep,'FunSurfRH',filesep, ...
                    'ROISignals_',Cfg.StartingDirName,'_',MaskSurfaceRightSet{iMask}], 'dir')
                mkdir([OutputDir,filesep,'Results',filesep,'FunSurfRH',filesep, ...
                    'ROISignals_',Cfg.StartingDirName,'_',MaskSurfaceRightSet{iMask}]);
            end
            DirName=dir(fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i}, ...
                '*fsaverage5_hemi-R*.func.gii'));
            % extract time series
            for iFile=1:length(DirName)
                FileName=DirName(iFile).name;
                [ROISignalsSurfRH] = y_ExtractROISignal_Surf( ...
                    fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i},FileName), ...
                            {[MaskDir,filesep,MaskSurfaceRightSet{iMask},'.gii']}, ...
                            [OutputDir,filesep,'Results',filesep,'FunSurfRH',filesep, ...
                            'ROISignals_',Cfg.StartingDirName,'_',MaskSurfaceRightSet{iMask}, ...
                            filesep,Cfg.SubjectID{i}], ...
                            '', ... % no brain mask
                            0);
            end

            % Calculate Functional Connectivity by Seed based Correlation Anlyasis
            % Left Hemi
            if ~exist([OutputDir,filesep,'Results',filesep,'FunSurfLH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_', ...
                    MaskSurfaceRightSet{iMask}], 'dir')
                
                mkdir([OutputDir,filesep,'Results',filesep,'FunSurfLH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_',MaskSurfaceRightSet{iMask}]);
            end
            DirName=dir(fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i}, ...
                '*fsaverage5_hemi-L*.func.gii'));
            for iFile=1:length(DirName)
                FileName=DirName(iFile).name;
                y_SCA_Surf(fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i},FileName), ...
                    {ROISignalsSurfRH}, ... 
                    [OutputDir,filesep,'Results',filesep,'FunSurfLH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_',MaskSurfaceRightSet{iMask}, ...
                    filesep,'FC_',Cfg.SubjectID{i},'.func.gii'], ...
                    Cfg.MaskFileSurfLH, ...
                    0);
            end

            % Right Hemi
            if ~exist([OutputDir,filesep,'Results',filesep,'FunSurfRH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_',MaskSurfaceRightSet{iMask}], 'dir')
                mkdir([OutputDir,filesep,'Results',filesep,'FunSurfRH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_',MaskSurfaceRightSet{iMask}]);
            end
            DirName=dir(fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i}, ...
                '*fsaverage5_hemi-R*.func.gii'));
            for iFile=1:length(DirName)
                FileName=DirName(iFile).name;
                y_SCA_Surf(fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i},FileName), ...
                    {ROISignalsSurfRH}, ... 
                    [OutputDir,filesep,'Results',filesep,'FunSurfRH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_',MaskSurfaceRightSet{iMask}, ...
                    filesep,'FC_',Cfg.SubjectID{i},'.func.gii'], ...
                    Cfg.MaskFileSurfRH, ...
                    0);
            end

            if (Cfg.IsProcessVolumeSpace==1) && ....
               (~exist([OutputDir,filesep,'Results',filesep,'FunVolu',filesep, ...
               'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName_Volume,'_', ...
                MaskSurfaceRightSet{iMask}], 'dir'))
            
                mkdir([OutputDir,filesep,'Results',filesep,'FunVolu',filesep, ...
                        'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName_Volume,'_', ...
                        MaskSurfaceRightSet{iMask}]);
            end
            % Volume
            if (Cfg.IsProcessVolumeSpace==1)
                % Calculate Functional Connectivity by Seed based Correlation Anlyasis
                y_SCA([Cfg.WorkingDir,filesep,Cfg.StartingDirName_Volume,filesep,Cfg.SubjectID{i}], ...
                    {ROISignalsSurfRH}, ...% use extracted time series as roi
                    [OutputDir,filesep,'Results',filesep,'FunVolu',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName_Volume,'_', ...
                    MaskSurfaceRightSet{iMask},filesep,'FC_',Cfg.SubjectID{i},'.nii'], ...
                    Cfg.MaskFileVolu, ...
                    0);
            end
        end
        
        % masks in the volume space
         for iMask = 1:length(MaskVolumeSet)
            if ~exist([OutputDir,filesep,'Results',filesep,'FunVolu',filesep, ...
                    'ROISignals_',Cfg.StartingDirName_Volume, ...
                    '_',MaskVolumeSet{iMask}], 'dir')
            mkdir([OutputDir,filesep,'Results',filesep,'FunVolu',filesep, ...
                'ROISignals_',Cfg.StartingDirName_Volume,'_', ...
                    MaskVolumeSet{iMask}]);
            end
            DirName=dir(fullfile(Cfg.WorkingDir,Cfg.StartingDirName_Volume, ...
                Cfg.SubjectID{i},'Filtered_4DVolume.nii'));
            
            
            % extract time series
            for iFile=1:length(DirName)
                FileName=DirName(iFile).name;
                [ROISignalsVolume] = y_ExtractROISignal(fullfile(Cfg.WorkingDir, ...
                            Cfg.StartingDirName_Volume,Cfg.SubjectID{i},FileName), ...
                            {[MaskDir,filesep,MaskVolumeSet{iMask},'_Reslice.nii']}, ...
                            [OutputDir,filesep,'Results',filesep,'FunVolu',filesep, ...
                            'ROISignals_',Cfg.StartingDirName_Volume,'_', ...
                            MaskVolumeSet{iMask},filesep,Cfg.SubjectID{i}], ...
                            '', ... % Will not restrict into the brain mask in extracting ROI signals
                            0);
            end
            % Calculate Functional Connectivity by Seed based Correlation Anlyasis
            % Left Hemi
            if ~exist([OutputDir,filesep,'Results',filesep,'FunSurfLH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_', ...
                    MaskVolumeSet{iMask}], 'dir')
                
                mkdir([OutputDir,filesep,'Results',filesep,'FunSurfLH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_',MaskVolumeSet{iMask}]);
            end
            DirName=dir(fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i}, ...
                '*fsaverage5_hemi-L*.func.gii'));
            for iFile=1:length(DirName)
                FileName=DirName(iFile).name;
                y_SCA_Surf(fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i},FileName), ...
                    {ROISignalsVolume}, ... 
                    [OutputDir,filesep,'Results',filesep,'FunSurfLH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_',MaskVolumeSet{iMask}, ...
                    filesep,'FC_',Cfg.SubjectID{i},'.func.gii'], ...
                    Cfg.MaskFileSurfLH, ...
                    0);
            end

            % Right Hemi
            if ~exist([OutputDir,filesep,'Results',filesep,'FunSurfRH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_',MaskVolumeSet{iMask}], 'dir')
                mkdir([OutputDir,filesep,'Results',filesep,'FunSurfRH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_',MaskVolumeSet{iMask}]);
            end
            DirName=dir(fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i}, ...
                '*fsaverage5_hemi-R*.func.gii'));
            for iFile=1:length(DirName)
                FileName=DirName(iFile).name;
                y_SCA_Surf(fullfile(Cfg.WorkingDir,Cfg.StartingDirName,Cfg.SubjectID{i},FileName), ...
                    {ROISignalsVolume}, ... 
                    [OutputDir,filesep,'Results',filesep,'FunSurfRH',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName,'_',MaskVolumeSet{iMask}, ...
                    filesep,'FC_',Cfg.SubjectID{i},'.func.gii'], ...
                    Cfg.MaskFileSurfRH, ...
                    0);
            end

            if (Cfg.IsProcessVolumeSpace==1) && ....
               (~exist([OutputDir,filesep,'Results',filesep,'FunVolu',filesep, ...
               'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName_Volume,'_', ...
                MaskVolumeSet{iMask}], 'dir'))
            
                mkdir([OutputDir,filesep,'Results',filesep,'FunVolu',filesep, ...
                        'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName_Volume,'_', ...
                        MaskVolumeSet{iMask}]);
            end
            % Volume
            if (Cfg.IsProcessVolumeSpace==1)
                % Calculate Functional Connectivity by Seed based Correlation Anlyasis
                y_SCA([Cfg.WorkingDir,filesep,Cfg.StartingDirName_Volume,filesep,Cfg.SubjectID{i}], ...
                    {ROISignalsVolume}, ...% use extracted time series as roi
                    [OutputDir,filesep,'Results',filesep,'FunVolu',filesep, ...
                    'FC_SeedSurfLHSurfRHVolu_',Cfg.StartingDirName_Volume,'_', ...
                    MaskVolumeSet{iMask},filesep,'FC_',Cfg.SubjectID{i},'.nii'], ...
                    Cfg.MaskFileVolu, ...
                    0);
            end
        end
    end
end

%% smooth with DPABISurf_Pipeline
poolobj = gcp('nocreate');
delete(poolobj);
parpool(30);

%%
Cfg = [];
load([WorkDir,'/Cfg_ForSmooth_V2.mat']);
WorkingDir = OutputDir;
DPABISurf_run(Cfg, WorkingDir, SubjectListFile);

